% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%
\usepackage{listings-rust}

\begin{document}

%==============================================================================
%% METADATA
\title{The IETF Transport Service API}
\author{Stuart Reilly}
\date{\today}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
    Network programming has been build around the Berkeley Sockets API since its inception in 1983.
    While the simplicity of this API, which abstracted file I/O and network I/O to a similar interface,
    is a testament to its longevity, modern network programming has changed in a manner which requires
    amounts of boilerplate code.
    This projects aims to investigate the possibility of a high-level API which removes the boilerplate
    associated with Berkeley sockets, and provide a protocol-agnostic, asynchronous API to application developers.
\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
\def\consentname {Stuart Reilly} % your full name
\def\consentdate {\today} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}

% reset page numbering. Don't remove this!
\pagenumbering{arabic} 

The Berkeley socket API (BSD sockets) allows an application to communicate over the Internet since 1983.
A key reason for its longevity is how a network socket is treated in the same way as a local file, once the socket has
been created.
This allows a programmer with understanding of local file I/O to work with network sockets.
While this model of network I/O has some similarities to local file I/O, in reality they are distinct and should be
treated as such.
One prime example of this is how network I/O has a range of protocols which can be used at each layer of the networking
stack, each providing different grantees and properties, and the application must specify which protocol stack to use.
Whereas in file I/O, there exists a protocol stack (file systems, storage interface, etc), but the application does not
need to manipulate the stack, as each protocol is a platform-specific way to handle the same operations.

Since BSD sockets required applications to decide the protocol stack, changing protocols would require the application
to be modified.
This may have contributed to the slow adoption of IPv6, since every application would have to be rewritten to use IPv6
rather than only the network implementation.
BSD sockets defined the default protocol to handle streams and datagrams are TCP and UDP, respectively.
While this may have aided in the adoption of these protocols and the growth of the Internet, it also hindered the
development of alternative protocols such as DCCP and SCTP .

Furthermore, BSD sockets exposes a synchronous API, providing blocking I/O .
Modern programming practices have changed to encourage the use of non-blocking I/O through the use of an asynchronous
API .
An asynchronous API allows the application to pass scheduling I/O calls to the implementation, often providing better
performance.

In order to resolve the above issues, a new networking API must be created.
Such an API must be protocol-agnostic and asynchronous, while allowing not reducing the possible uses of the API in
comparison to BSD sockets.
By being protocol-agnostic, the API decouples applications from the transport-layer, allowing new protocols to be
designed and used without applications having to be modified.
Modern network programming relies on asynchronous networking, which previously would require boilerplate over BSD
sockets.
By having the API be asynchronous, this boilerplate can be removed.

The aim of this project is to create an API which fulfills these requirements, and evaluate it in comparison to BSD
sockets.
The IETF Transport Services API will provide the overall design of the API, and Rust will be the implementation language
used.
Rust provides high-level safety with low-level performance and access, while also having be designed with concurrent
programming in mind.


Why should the reader care about what are you doing and what are you actually doing?
\section{Guidance}

\textbf{Motivate} first, then state the general problem clearly. 

\section{Writing guidance}
\subsection{Who is the reader?}

This is the key question for any writing. Your reader:

\begin{itemize}
    \item
    is a trained computer scientist: \emph{don't explain basics}.
    \item
    has limited time: \emph{keep on topic}.
    \item
    has no idea why anyone would want to do this: \emph{motivate clearly}
    \item
    might not know \emph{anything} about your project in particular:
    \emph{explain your project}.
    \item
    but might know precise details and check them: \emph{be precise and
    strive for accuracy.}
    \item
    doesn't know or care about you: \emph{personal discussions are
    irrelevant}.
\end{itemize}

Remember, you will be marked by your supervisor and one or more members
of staff. You might also have your project read by a prize-awarding
committee or possibly a future employer. Bear that in mind.

%\subsection{References and style guides}
%There are many style guides on good English writing. You don't need to
%read these, but they will improve how you write.

%\begin{itemize}
    %\item
    %\emph{How to write a great research paper} \cite{Pey17} (\textbf{recommended}, even though you aren't writing a research paper)
    %\item
    %\emph{How to Write with Style} \cite{Von80}. Short and easy to read. Available online.
    %\item
    %\emph{Style: The Basics of Clarity and Grace} \cite{Wil09} A very popular modern English style guide.
    %\item
    %\emph{Politics and the English Language} \cite{Orw68}  A famous essay on effective, clear writing in English.
    %\item
    %\emph{The Elements of Style} \cite{StrWhi07} Outdated, and American, but a classic.
    %\item
    %\emph{The Sense of Style} \cite{Pin15} Excellent, though quite in-depth.
%\end{itemize}

%\subsubsection{Citation styles}

%\begin{itemize}
%\item If you are referring to a reference as a noun, then cite it as: ``\citet{Orw68} discusses the role of language in political thought.''
%\item If you are referring implicitly to references, use: ``There are many good books on writing \citep{Orw68, Wil09, Pin15}.''
%\end{itemize}

There is a complete guide on good citation practice by Peter Coxhead available here: \url{http://www.cs.bham.ac.uk/~pxc/refs/index.html}. 
If you are unsure about how to cite online sources, please see this guide: \url{https://student.unsw.edu.au/how-do-i-cite-electronic-sources}.

\subsection{Plagiarism warning}

\begin{highlight_title}{WARNING}
    
    If you include material from other sources without full and correct attribution, you are commiting plagiarism. The penalties for plagiarism are severe.
    Quote any included text and cite it correctly. Cite all images, figures, etc. clearly in the caption of the figure.
\end{highlight_title}


%==================================================================================================================================
\chapter{Background}

\section{Rust}

Rust is a modern systems programming language, which aids developers "write faster, more reliable software", according
to the Rust book (\cite{kalbnik_rust_nodate}).
Rust targets systems level programming, similar to C and C++, but provides much greater safety in comparison.

One major issue with writing system software is ownership.
Who owns a resource, such as memory or file handles, and for how long.
In higher level languages, a garbage collector will ensure no resources live longer than they are needed, often through
the use of reference counting.
Garbage collection does elevate the burden of resource management from the developer, but in return, the developer has
much less control over resources, and the resources will live of a non-deterministic length of time with most garbage
collectors.
Languages like C and C++ require the programmer to manage resources, releasing them manually, leading to unreleased
resources if implemented incorrectly.
Rust enforces correct resource management by delegating all resource management to the compiler, through its borrow
checker.
Only a single entity can own a resource in Rust.
All other entities must use references to interact with the resource.
Furthermore, either a single mutable reference or an arbitrary number of immutable references can exist for a resource
at once.
These references cannot live longer than the entity owning the resource, which is enforced by the compiler.
When a reference goes out of scope, it is freed.
When an entity goes out of scope, there must be no remaining references to the entity, and the resources the entity owns
are freed.
Through this method, invalid references cannot exist, and it is impossible to release a resource which has already been
released.
A side effect of only allowing a single mutable reference, or an arbitrary number of immutable references, the compiler
can guarantee a compiled program is data race free.
This is because, only a single entity can modify a resource, while knowing no other entities can read the resource or
modify the resource.

Being a modern language, Rust provides some higher level concepts and construct to systems programming.
While Rust is a statically typed language, it provides local type inference, allowing for cleaning code.
Its type-system is inspired by other languages such as Haskell, as such a programmer can express a large amount of
information through the types they use alone.
Furthermore, Rust has support for higher-order functions, because functions are a first-class type.
Functions, such as map and fold, are provided, not directly for collections of items, rather iterators.
Iterators in Rust provide a functional method for working with collections of items, while providing performance similar
to a comparable loop construct.

Rust also emphasises its ability to provide "zero-cost abstractions".
This means using high level constructs, such as iterators, do not inure any performance cost over using lower-level
constructs, allowing for code to be written faster and cleaner, without any performance impact.
Another example is Rust's Option type, which is either Some wrapping an object, or None.
This is equivalent to a NULL-pointer check in C, due to Rust's null-pointer optimisation, but is much safer as the
type-system forces the programmer to check for the presence of an object.
A Future in Rust is a type which is polled until it is complete.
A key feature of Rust's Futures is they only carry out work when polled, so there is no extra cost to use a Future.
Rather than polling all the Futures manually, a runtime is used to manage the Futures.
The runtime is responsible for distributing the Futures among its worker poll if applicable, and ensuring each Future is
polled.

Recently, Rust introduced support for async/await syntax.
A function can be marked as async, which changes the return type to be a Futures wrapping the original return type.
When an async function reaches an await, the poll being used to progress the Future returns Pending, informing the
runtime another Future should be polled.
The Future will continue to return Pending until the Future being awaited completes, at which point the function will
continue until the next await or the function returns.
The new syntax allows for asynchronous code to be written quickly and cleanly with no runtime cost, compared to manually
handling Futures.

What did other people do, and how is it relevant to what you want to do?
\section{Guidance}
\begin{itemize}    
    \item
      Don't give a laundry list of references.
    \item
      Tie everything you say to your problem.
    \item
      Present an argument.
    \item Think critically; weigh up the contribution of the background and put it in context.    
    \item
      \textbf{Don't write a tutorial}; provide background and cite
      references for further information.
\end{itemize}

%==================================================================================================================================
\chapter{Analysis/Requirements}
The project will aim to produce a high-level, typed and asynchronous networking API in the Rust programming language,
making use of Rust's async/await syntax and Futures.
This API is intended to be a replacement for BSD sockets, and as such will provide similar functionality, albeit at a
higher level.

In this chapter we define a set of functional and non-functional requirements, splitting each into ''required'' and
''optional''.
These requirements must fulfill the aims outlined in Chapter 1 and are intended to be built upon and make use of the
prior research discussed in Chapter 2.

\section{Functional Requirements}

\subsection{Required}

The API must provide enough functionality to support a single-client and single-server example.
This is required, because this is a minimum requirement to be able to be a basic replacement for BSD sockets.
Furthermore, most network communication occur this style, and the remaining can be recreated using this style.
As such a Preconnection must be defined which can initiate a Connection object, or begin listening for Connections.

The API must be asynchronous, utilising futures as the mechanism of handling asynchronous events.
This is required, because one the main issues with BSD sockets discussed in chapter 1 was its synchronous nature.
Asynchronous network programming is the modern technique, as such must be the primary method of using a new networking
API .
Futures are the de facto standard method for asynchronous programming in Rust, as such they shall be used.

The API must define a Connection object which can send and receive typed data.
As discussed in chapter 1, one of the issues with BSD sockets is they only support sending byte streams or byte
datagrams for TCP and UDP sockets respectively.
As such the API must expose a mechanism for typed data to be passed to a Connection object, which will converted into
the appropriate byte structure by the Connection object.

The API must define a mechanism to frame messages of a known size.
This is required, because in order to transform underlying transport layer data to and from useful message data,
it must be framed.
Without a framing mechanism, a byte-stream based transport layer will not be able to send and received typed data,
which is required by the previous requirement, and has been discussed as an issue with BSD sockets in chapter 1.

\subsection{Optional}

The API could provide a mechanism to frame messages of an unknown size.
This would allow byte-stream based transport layer data to be transformed to and from useful message data, even without
knowing the size of the data being transferred.
Since this section of the TAPS specification is currently not well-defined and is under continuous modification,
this will not be required to be implemented by this project.

The API could provide a Connection object which can receive partial data.
Since the underlying transport layer could not provide reliable data transfer, the Connection object could provide
partial data, which could be completed with subsequent packets.
Since this section of the TAPS specification is currently not well-defined and is under continuous modification, this
will not be required to be implemented by this project.

The API could provide a mechanism to enforce Preconnection object validity at compile-time through the use of Rust's
type system.
A Preconnection requires a remote endpoint or local endpoint in order to initiate a Connection or begin listening for
Connections, respectively.
This can be implemented through a runtime error trivially, but in order to ensure the API is as safe as possible, this
could be implemented as a compile-time error.
Since implementing this as a compile-time error is non-trivial, and does not impact the usability of the API, this will
not be required to implement this project.

\section{Non-Functional Requirements}

\subsection{Required}

The API must expose a "self-documenting" API, meaning the names of methods, method arguments, objects and constants must be
meaningful and describe their use.
This ensures the API describes how to use itself through its naming, using explicit documentation to augment this description.
Furthermore, this lowers to learning curve of the API, possibly increasing rate of adoption.

The API must allow users of the API to provide their own types for sending and receiving over a Connection.
Without this mechanism, the API will be very restrictive and not useful.
The Rust ecosystem has support for arbitrary type serialisation and deserialisation through the Serde library, as such this
will likely be used to provide this mechanism.

\subsection{Optional}

The API should not have a large impact performance over raw BSD sockets.
A large performance impact will hinder the adoption of the API, and as such should be avoided.
Since this is primarily a proof-of-concept project, this is not required, but should still be taken into account.

\section{Guidance}
Make it clear how you derived the constrained form of your problem via a clear and logical process. 

%==================================================================================================================================
\chapter{Design}
In this section, we discuss the high level design of the API, without implementation specific details.
Rust will be used for demonstrating the ideas discussed as it supports the required features, although no guarantee is
given for if the examples successfully compile.

\section{Abstract API}
The API will be expressed through abstract types with multiple possible concrete implementations.
Users of the API will operate exclusively with the abstract types in order to allow the underlying implementation to
change with minimal changes to the user's code.

The Connection, Preconnection and Listener types will be generic over the framer used to frame the data which the
connections will be operating on. \emph{The preceding may change to just the data being transferred.}
This will ensure the connections can only handle a specific strongly-typed data type.
All methods on the Connection type which either receive data or send data will utilise this generic parameter in their
return value and parameters respectively.
The Preconnection's listen and initiate methods will pass this generic parameter to the new Listener object or
Connection object respectively.

The close and abort functions of the Connection type will consume the connection, rather than taking a mutable reference
like other methods.
A compiler can then ensure the connection is never used after being closed or aborted.
For example, the Rust compiler will drop the connection object within the close or abort functions, and ensure no other
variables have ownership of the connection when it is closed or aborted.

A Framer type is a type which can frame and deframe a given piece of data, as well as optionally store metadata for use
in framing and deframing.
The Framer must be generic over the data type it will frame and deframe.
An example is a HTTP framer, which can frame encodable data by prepending the data with a HTTP request header, which can
be configured by giving the framer metadata.
A HTTP framer would also deframe decodable data be first parsing a HTTP response header.

Data which can be framed/deframed must be able to be encoded and decoded from raw bytes if it is to be a Framer's input
and output data type respectively.
As such they must be an Encode type and/or a Decode type, which define a type which can be encoded into bytes and
decoded from raw bytes respectively.
An Encode type should also provide a hint to the encoded size of the type, to allow for memory to be preallocated if
required.

\section{Application Layer Protocols}
Application layer protocols have requirements for the protocol stack they operate on, such as HTTP requiring a reliable
protocol stack.
Having the user of the API specify these requirements will require unnecessary boilerplate, so an abstract Protocol type
will be defined.
A Protocol type must specify the protocol stack requirements required for the protocol.
As shown in Listing \ref{lst:proto_funcs}, the Protocol type can be used to allow the user of the API to create a
Connection or Listener without constructing a valid Preconnection manually.
Furthermore, by defining an abstract Protocol type, other libraries can implement this and extend the application layer
protocols supported in the ecosystem.

\begin{lstlisting}[language=Rust, float=h, label=lst:proto_funcs, caption={An example of functions which utilise the
    abstract Protocol type.}]
pub async fn new_connection<P, D>(endpoint: Endpoint) -> Connection<D>
    where
        P: Protocol,
        D: P::Data;
pub async fn new_listener<P, D>(endpoint: Endpoint) -> Listener<D>
    where
        P: Protocol,
        D: P::Data;
\end{lstlisting}

\section{Flow}

As shown in Figure \ref{fig:flow}, there are both asynchronous and synchronous sections of opening a Connection.
The asynchronous sections are when the program would have to carry out some I/O, for example binding a Listener to a
port.
The remaining sections are either a trivial object creation or solving properties, as such are synchronous.
Solving properties can contain a concurrent implementation if the implementation deems this necessary.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{diagrams/flow}
    \caption{A diagram to show how the three main objects flow from one to another.
    Oval nodes are objects, rectangular nodes are states in the transition between objects, dashed arrows are
    asynchronous state changes, and solid arrows are synchronous state changes.}
    \label{fig:flow}
\end{figure}

\section{Connection Racing}
Since the API is protocol-agnostic, there must be a mechanism of determining the protocol stack to use internally.
This can result in multiple possible protocol stacks, for example TCP-over-IPv4 and SCTP-over-IPv6.
Each protocol stack will be initialised and raced to find the optimal stack.
Racing will implement the IETF Happy Eyeballs algorithm, in which less-desirable protocol stacks are given a delay
before joining the race.
As well as different protocol stacks, different IP addresses will be raced.
DNS resolution will result in the set of addresses to race.
While this can result in a large number of connections to race, the use of Happy Eyeballs will reduce the number of
connections being raced simultaneously.

Each of the possible protocol stack and address combinations will be raced asynchronously.
Once the first connection is established, all other possible connections will be closed and the successful connection
will be returned.
Remaining connections will be closed asynchronously, allowing the race function to return quickly.
A timeout could be used for closing the connections, resulting in an abort if the connection fails to close promptly,
but this choice will be left as an implementation detail.
The result of multiple connections being established at the same time will be left as an implementation detail.

%==================================================================================================================================
\chapter{Implementation}

\section{Trait Objects}
In order to allow for the underlying implementation of the API to change with minimal modification to code using the API,
the main objects (Preconnection, Listener and Connection) had to be implemented using trait objects.
Trait objects are Rust's method of dynamic dispatch.
While using trait objects would add a performance overhead due to pointer indirection and dynamic dispatch, the benefit
of allowing the implementation to change out ways this.

% Notes:
% - Uses trait objects
% - Had to define all fn(self) as fn(self: Box<Self>) as needs known size
% - Async trait fn requires third-party crate
% - Connection racing adds artificial 5ms delay to IPv4 to encourage IPv6 usage
% - Tokio hidden by ?(feature-flag, generic param)?

What did you do to implement this idea, and what technical achievements did you make?
\section{Guidance}
You can't talk about everything. Cover the high level first, then cover important, relevant or impressive details.



\section{General points}

These points apply to the whole dissertation, not just this chapter.



\subsection{Figures}
\emph{Always} refer to figures included, like Figure \ref{fig:relu}, in the body of the text. Include full, explanatory captions and make sure the figures look good on the page.
You may include multiple figures in one float, as in Figure \ref{fig:synthetic}, using \texttt{subcaption}, which is enabled in the template.



% Figures are important. Use them well.
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{images/relu.pdf}    

    \caption{In figure captions, explain what the reader is looking at: ``A schematic of the rectifying linear unit, where $a$ is the output amplitude,
    $d$ is a configurable dead-zone, and $Z_j$ is the input signal'', as well as why the reader is looking at this: 
    ``It is notable that there is no activation \emph{at all} below 0, which explains our initial results.'' 
    \textbf{Use vector image formats (.pdf) where possible}. Size figures appropriately, and do not make them over-large or too small to read.
    }

    % use the notation fig:name to cross reference a figure
    \label{fig:relu} 
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic.png}
        \caption{Synthetic image, black on white.}
        \label{fig:syn1}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic_2.png}
        \caption{Synthetic image, white on black.}
        \label{fig:syn2}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
    %(or a blank line to force the subfigure onto a new line)    
    \caption{Synthetic test images for edge detection algorithms. \subref{fig:syn1} shows various gray levels that require an adaptive algorithm. \subref{fig:syn2}
    shows more challenging edge detection tests that have crossing lines. Fusing these into full segments typically requires algorithms like the Hough transform.
    This is an example of using subfigures, with \texttt{subref}s in the caption.
    }\label{fig:synthetic}
\end{figure}

\clearpage

\subsection{Equations}

Equations should be typeset correctly and precisely. Make sure you get parenthesis sizing correct, and punctuate equations correctly 
(the comma is important and goes \textit{inside} the equation block). Explain any symbols used clearly if not defined earlier. 

For example, we might define:
\begin{equation}
    \hat{f}(\xi) = \frac{1}{2}\left[ \int_{-\infty}^{\infty} f(x) e^{2\pi i x \xi} \right],
\end{equation}    
where $\hat{f}(\xi)$ is the Fourier transform of the time domain signal $f(x)$.

\subsection{Algorithms}
Algorithms can be set using \texttt{algorithm2e}, as in Algorithm \ref{alg:metropolis}.

% NOTE: line ends are denoted by \; in algorithm2e
\begin{algorithm}
    \DontPrintSemicolon
    \KwData{$f_X(x)$, a probability density function returing the density at $x$.\; $\sigma$ a standard deviation specifying the spread of the proposal distribution.\;
    $x_0$, an initial starting condition.}
    \KwResult{$s=[x_1, x_2, \dots, x_n]$, $n$ samples approximately drawn from a distribution with PDF $f_X(x)$.}
    \Begin{
        $s \longleftarrow []$\;
        $p \longleftarrow f_X(x)$\;
        $i \longleftarrow 0$\;
        \While{$i < n$}
        {
            $x^\prime \longleftarrow \mathcal{N}(x, \sigma^2)$\;
            $p^\prime \longleftarrow f_X(x^\prime)$\;
            $a \longleftarrow \frac{p^\prime}{p}$\;
            $r \longleftarrow U(0,1)$\;
            \If{$r<a$}
            {
                $x \longleftarrow x^\prime$\;
                $p \longleftarrow f_X(x)$\;
                $i \longleftarrow i+1$\;
                append $x$ to $s$\;
            }
        }
    }
    
\caption{The Metropolis-Hastings MCMC algorithm for drawing samples from arbitrary probability distributions, 
specialised for normal proposal distributions $q(x^\prime|x) = \mathcal{N}(x, \sigma^2)$. The symmetry of the normal distribution means the acceptance rule takes the simplified form.}\label{alg:metropolis}
\end{algorithm}

\subsection{Tables}

If you need to include tables, like Table \ref{tab:operators}, use a tool like https://www.tablesgenerator.com/ to generate the table as it is
extremely tedious otherwise. 

\begin{table}[]
    \caption{The standard table of operators in Python, along with their functional equivalents from the \texttt{operator} package. Note that table
    captions go above the table, not below. Do not add additional rules/lines to tables. }\label{tab:operators}
    %\tt 
    \rowcolors{2}{}{gray!3}
    \begin{tabular}{@{}lll@{}}
    %\toprule
    \textbf{Operation}    & \textbf{Syntax}                & \textbf{Function}                            \\ %\midrule % optional rule for header
    Addition              & \texttt{a + b}                          & \texttt{add(a, b)}                                    \\
    Concatenation         & \texttt{seq1 + seq2}                    & \texttt{concat(seq1, seq2)}                           \\
    Containment Test      & \texttt{obj in seq}                     & \texttt{contains(seq, obj)}                           \\
    Division              & \texttt{a / b}                          & \texttt{div(a, b) }  \\
    Division              & \texttt{a / b}                          & \texttt{truediv(a, b) } \\
    Division              & \texttt{a // b}                         & \texttt{floordiv(a, b)}                               \\
    Bitwise And           & \texttt{a \& b}                         & \texttt{and\_(a, b)}                                  \\
    Bitwise Exclusive Or  & \texttt{a \textasciicircum b}           & \texttt{xor(a, b)}                                    \\
    Bitwise Inversion     & \texttt{$\sim$a}                        & \texttt{invert(a)}                                    \\
    Bitwise Or            & \texttt{a | b}                          & \texttt{or\_(a, b)}                                   \\
    Exponentiation        & \texttt{a ** b}                         & \texttt{pow(a, b)}                                    \\
    Identity              & \texttt{a is b}                         & \texttt{is\_(a, b)}                                   \\
    Identity              & \texttt{a is not b}                     & \texttt{is\_not(a, b)}                                \\
    Indexed Assignment    & \texttt{obj{[}k{]} = v}                 & \texttt{setitem(obj, k, v)}                           \\
    Indexed Deletion      & \texttt{del obj{[}k{]}}                 & \texttt{delitem(obj, k)}                              \\
    Indexing              & \texttt{obj{[}k{]}}                     & \texttt{getitem(obj, k)}                              \\
    Left Shift            & \texttt{a \textless{}\textless b}       & \texttt{lshift(a, b)}                                 \\
    Modulo                & \texttt{a \% b}                         & \texttt{mod(a, b)}                                    \\
    Multiplication        & \texttt{a * b}                          & \texttt{mul(a, b)}                                    \\
    Negation (Arithmetic) & \texttt{- a}                            & \texttt{neg(a)}                                       \\
    Negation (Logical)    & \texttt{not a}                          & \texttt{not\_(a)}                                     \\
    Positive              & \texttt{+ a}                            & \texttt{pos(a)}                                       \\
    Right Shift           & \texttt{a \textgreater{}\textgreater b} & \texttt{rshift(a, b)}                                 \\
    Sequence Repetition   & \texttt{seq * i}                        & \texttt{repeat(seq, i)}                               \\
    Slice Assignment      & \texttt{seq{[}i:j{]} = values}          & \texttt{setitem(seq, slice(i, j), values)}            \\
    Slice Deletion        & \texttt{del seq{[}i:j{]}}               & \texttt{delitem(seq, slice(i, j))}                    \\
    Slicing               & \texttt{seq{[}i:j{]}}                   & \texttt{getitem(seq, slice(i, j))}                    \\
    String Formatting     & \texttt{s \% obj}                       & \texttt{mod(s, obj)}                                  \\
    Subtraction           & \texttt{a - b}                          & \texttt{sub(a, b)}                                    \\
    Truth Test            & \texttt{obj}                            & \texttt{truth(obj)}                                   \\
    Ordering              & \texttt{a \textless b}                  & \texttt{lt(a, b)}                                     \\
    Ordering              & \texttt{a \textless{}= b}               & \texttt{le(a, b)}                                     \\
    % \bottomrule
    \end{tabular}
    \end{table}
\subsection{Code}

Avoid putting large blocks of code in the report (more than a page in one block, for example). Use syntax highlighting if possible, as in Listing \ref{lst:callahan}.

\begin{lstlisting}[language=python, float, caption={The algorithm for packing the $3\times 3$ outer-totalistic binary CA successor rule into a 
    $16\times 16\times 16\times 16$ 4 bit lookup table, running an equivalent, notionally 16-state $2\times 2$ CA.}, label=lst:callahan]
    def create_callahan_table(rule="b3s23"):
        """Generate the lookup table for the cells."""        
        s_table = np.zeros((16, 16, 16, 16), dtype=np.uint8)
        birth, survive = parse_rule(rule)

        # generate all 16 bit strings
        for iv in range(65536):
            bv = [(iv >> z) & 1 for z in range(16)]
            a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = bv

            # compute next state of the inner 2x2
            nw = apply_rule(f, a, b, c, e, g, i, j, k)
            ne = apply_rule(g, b, c, d, f, h, j, k, l)
            sw = apply_rule(j, e, f, g, i, k, m, n, o)
            se = apply_rule(k, f, g, h, j, l, n, o, p)

            # compute the index of this 4x4
            nw_code = a | (b << 1) | (e << 2) | (f << 3)
            ne_code = c | (d << 1) | (g << 2) | (h << 3)
            sw_code = i | (j << 1) | (m << 2) | (n << 3)
            se_code = k | (l << 1) | (o << 2) | (p << 3)

            # compute the state for the 2x2
            next_code = nw | (ne << 1) | (sw << 2) | (se << 3)

            # get the 4x4 index, and write into the table
            s_table[nw_code, ne_code, sw_code, se_code] = next_code

        return s_table

\end{lstlisting}

%==================================================================================================================================
\chapter{Evaluation} 
How good is your solution? How well did you solve the general problem, and what evidence do you have to support that?

\section{Guidance}
\begin{itemize}
    \item
        Ask specific questions that address the general problem.
    \item
        Answer them with precise evidence (graphs, numbers, statistical
        analysis, qualitative analysis).
    \item
        Be fair and be scientific.
    \item
        The key thing is to show that you know how to evaluate your work, not
        that your work is the most amazing product ever.
\end{itemize}

\section{Evidence}
Make sure you present your evidence well. Use appropriate visualisations, reporting techniques and statistical analysis, as appropriate.

If you visualise, follow the basic rules, as illustrated in Figure \ref{fig:boxplot}:
\begin{itemize}
\item Label everything correctly (axis, title, units).
\item Caption thoroughly.
\item Reference in text.
\item \textbf{Include appropriate display of uncertainty (e.g. error bars, Box plot)}
\item Minimize clutter.
\end{itemize}

See the file \texttt{guide\_to\_visualising.pdf} for further information and guidance.

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{images/boxplot_finger_distance.pdf}    

    \caption{Average number of fingers detected by the touch sensor at different heights above the surface, averaged over all gestures. Dashed lines indicate
    the true number of fingers present. The Box plots include bootstrapped uncertainty notches for the median. It is clear that the device is biased toward 
    undercounting fingers, particularly at higher $z$ distances.
    }

    % use the notation fig:name to cross reference a figure
    \label{fig:boxplot} 
\end{figure}


%==================================================================================================================================
\chapter{Conclusion}    
Summarise the whole project for a lazy reader who didn't read the rest (e.g. a prize-awarding committee).
\section{Guidance}
\begin{itemize}
    \item
        Summarise briefly and fairly.
    \item
        You should be addressing the general problem you introduced in the
        Introduction.        
    \item
        Include summary of concrete results (``the new compiler ran 2x
        faster'')
    \item
        Indicate what future work could be done, but remember: \textbf{you
        won't get credit for things you haven't done}.
\end{itemize}

%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

Typical inclusions in the appendices are:

\begin{itemize}
\item
  Copies of ethics approvals (required if obtained)
\item
  Copies of questionnaires etc. used to gather data from subjects.
\item
  Extensive tables or figures that are too bulky to fit in the main body of
  the report, particularly ones that are repetitive and summarised in the body.

\item Outline of the source code (e.g. directory structure), or other architecture documentation like class diagrams.

\item User manuals, and any guides to starting/running the software.

\end{itemize}

\textbf{Don't include your source code in the appendices}. It will be
submitted separately.

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
